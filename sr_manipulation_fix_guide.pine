// STEP-BY-STEP GUIDE TO UPDATE YOUR S&R MANIPULATION DETECTION
// File: enhanced_sr_manipulation_guide.pine

/*
=============================================================================
MANIPULATION DETECTION FIXES FOR YOUR S&R SCRIPT
=============================================================================

PROBLEM IDENTIFIED:
Your current detectManipulation() function has logical errors that cause 
false positive detection of manipulations.

CURRENT ISSUES:
1. For Resistance: close <= sr.price * (1 + manipMargin / 100.0) 
   - This INCORRECTLY allows closes ABOVE resistance
   - Should be: close < sr.price (must close BELOW resistance)

2. For Support: close >= sr.price * (1 - manipMargin / 100.0)
   - This INCORRECTLY allows closes BELOW support  
   - Should be: close > sr.price (must close ABOVE support)

3. Missing volume confirmation
4. No ATR-based validation
5. No rejection strength measurement

=============================================================================
STEP 1: REPLACE THE detectManipulation FUNCTION
=============================================================================
*/

// REPLACE THIS (your current function):
/*
detectManipulation(srInfo sr, float manipMargin) =>
    bool isManipulation = false
    if sr.srType == "Resistance"
        if high > sr.price and close <= sr.price * (1 + manipMargin / 100.0)
            isManipulation := true
    else if sr.srType == "Support"
        if low < sr.price and close >= sr.price * (1 - manipMargin / 100.0)
            isManipulation := true
    isManipulation
*/

// WITH THIS (enhanced version):
detectManipulation(srInfo sr, float manipMargin, float currentATR, float currentAvgVolume) =>
    bool isManipulation = false
    marginDistance = sr.price * (manipMargin / 100.0)
    
    // Volume confirmation for manipulation detection
    volumeSpike = nz(volume) >= currentAvgVolume * 1.2
    quickReversal = math.abs(high - low) >= currentATR * 0.8
    
    if sr.srType == "Resistance"
        // Liquidity sweep above resistance with rejection back below
        priceBreak = high > sr.price + (currentATR * 0.1)  // Clear break above
        falseBreak = close < sr.price - (currentATR * 0.05) // MUST close BELOW resistance
        withinMargin = high <= sr.price + marginDistance
        
        isManipulation := priceBreak and falseBreak and withinMargin and volumeSpike and quickReversal
        
    else if sr.srType == "Support"
        // Liquidity sweep below support with rejection back above
        priceBreak = low < sr.price - (currentATR * 0.1)   // Clear break below
        falseBreak = close > sr.price + (currentATR * 0.05) // MUST close ABOVE support
        withinMargin = low >= sr.price - marginDistance
        
        isManipulation := priceBreak and falseBreak and withinMargin and volumeSpike and quickReversal
    
    isManipulation

/*
=============================================================================
STEP 2: ADD MANIPULATION STRENGTH FUNCTION
=============================================================================
*/

// ADD this new function after detectManipulation:
getManipulationStrength(srInfo sr, float currentATR) =>
    strength = "WEAK"
    if sr.srType == "Resistance"
        sweepDistance = high - sr.price
        rejectionStrength = sr.price - close
        strengthValue = (sweepDistance + rejectionStrength) / currentATR
    else
        sweepDistance = sr.price - low  
        rejectionStrength = close - sr.price
        strengthValue = (sweepDistance + rejectionStrength) / currentATR
    
    if strengthValue > 2.0
        strength := "STRONG"
    else if strengthValue > 1.0
        strength := "MEDIUM"
    
    strength

/*
=============================================================================
STEP 3: UPDATE THE FUNCTION CALL
=============================================================================
*/

// FIND this line in your code (around line 513):
// if detectManipulation(curSRInfo, manipulationMargin)

// REPLACE IT WITH:
// if detectManipulation(curSRInfo, manipulationMargin, atr, avgVolume)
//     curSRInfo.hasManipulation := true
//     curSRInfo.manipulationTimes.unshift(time)
//     
//     // Optional: Store manipulation strength
//     manipStrength = getManipulationStrength(curSRInfo, atr)

/*
=============================================================================
STEP 4: OPTIONAL ENHANCEMENTS
=============================================================================
*/

// 1. Add manipulation strength to srInfo type (optional):
// type srInfo
//     ...existing fields...
//     string manipulationStrength = na

// 2. Enhanced manipulation zone visualization with strength:
// if showManipulation and sr.hasManipulation and sr.manipulationTimes.size() > 0
//     for i = sr.manipulationTimes.size() - 1 to 0
//         manipTime = sr.manipulationTimes.get(i)
//         if manipTime >= sr.startTime and (na(sr.breakTime) or manipTime < sr.breakTime)
//             zoneColor = sr.srType == "Resistance" ? manipulationResistanceColor : manipulationSupportColor
//             strength = getManipulationStrength(sr, ta.atr(14))
//             
//             // Different opacity based on strength
//             finalColor = strength == "STRONG" ? color.new(zoneColor, 60) : 
//                         strength == "MEDIUM" ? color.new(zoneColor, 75) : 
//                         color.new(zoneColor, 85)

/*
=============================================================================
BENEFITS OF THESE CHANGES:
=============================================================================

1. ✅ FIXED LOGIC ERRORS: Close conditions now correctly validate manipulation
2. ✅ VOLUME CONFIRMATION: Requires 1.2x average volume for manipulation
3. ✅ ATR VALIDATION: Ensures significant price movement for detection
4. ✅ QUICK REVERSAL: Confirms large wicks indicating rejection
5. ✅ STRENGTH CLASSIFICATION: Categorizes manipulation as WEAK/MEDIUM/STRONG
6. ✅ ENHANCED PRECISION: More accurate manipulation detection
7. ✅ REDUCED FALSE SIGNALS: Better filtering of true manipulations

RESULT: Much more accurate manipulation detection with fewer false positives!
*/
